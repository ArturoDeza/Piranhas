function [hvdd] = orient_filtnew(pyr, sigma)%% ORIENT_FILTNEW	Filters "pyr" (in principle, one level of the% 		Gaussian pyramid generated by gausspyr) with 2nd%		derivative filters in 4 directions%%	Usage: [hvdd] = orient_filt(pyr)%		Where hvdd is the 4 output images concatenated %		together, in the order horizontal, vertical, up-left,%		and down-right.if nargin < 2,    sigma = 16/14;endhalfsupport = round(3*sigma);   % halfsupport was 10, for default sigma.  We need a halfsupport of about% 2*sigma for a single Gaussian.  Here we have three, one at -sigma, one at% sigma, so we should need a halfsupport of about 3*sigma.sigy = sigma; sigx = sigma; % Was sigx = 3*sigma.gx = RRgaussfilter1D(halfsupport, sigx);gy = RRgaussfilter1D(halfsupport, sigy, sigma);Ga = conv2(gx, gy');    Ga = Ga/sum(sum(Ga));gy = RRgaussfilter1D(halfsupport, sigy);Gb = conv2(gx, gy');    Gb = Gb/sum(sum(Gb));gy = RRgaussfilter1D(halfsupport, sigy, -sigma);Gc = conv2(gx, gy');    Gc = Gc/sum(sum(Gc));H = -Ga+2*Gb-Gc;V = H';GGa = imrotate(Ga, 45, 'bicubic', 'crop');   GGa = GGa/sum(sum(GGa));GGb = imrotate(Gb, 45, 'bicubic', 'crop');   GGb = GGb/sum(sum(GGb));GGc = imrotate(Gc, 45, 'bicubic', 'crop');   GGc = GGc/sum(sum(GGc));R = -GGa+2*GGb-GGc;GGa = imrotate(Ga, -45, 'bicubic', 'crop');   GGa = GGa/sum(sum(GGa));GGb = imrotate(Gb, -45, 'bicubic', 'crop');   GGb = GGb/sum(sum(GGb));GGc = imrotate(Gc, -45, 'bicubic', 'crop');   GGc = GGc/sum(sum(GGc));L = -GGa+2*GGb-GGc;hout = filt2(H,pyr);vout = filt2(V,pyr);lout = filt2(L,pyr);rout = filt2(R,pyr);hvdd = [hout vout lout rout];return;